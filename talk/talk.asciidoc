= Does JavaScript Adopts Functional Programming?
:Author: Yoav Luft
:Email:  <yoav.luft@gmail.com>
:Twitter: @luftyoav
:icons: font
:source-highlighter: highlightjs
:customcss: custom.css

icon:twitter[] @luftyoav

icon:envelope[] yoav.luft@gmail.com

[NOTE.speaker]
--
Hello! My name is Yoav Luft and today I'm going to talk about whether the JavaScript community adopts functional
programming or not. In this talk I'll present preliminary results from an on-going research I'm conducting under the
supervision of Prof. Feitelson from the Hebrew University of Jerusalem. In this talk I'll include other material not
from the research, and any mistakes or misinterpretations are my own only.

The talk will be divided into 4 parts:
--

== Table of Contents

- Why should we care about JavaScript?
- What "adopting functional programming" even means?
- Where is the evidence?
- What's next?

[NOTE.speaker]
--

- Why should we care about JavaScript?
- What "adopting functional programming" even means?
- Where is the evidence?
- What's next?

and finally,
--

== Spoiler Alert

video::images/spoilers.mp4[options="autoplay,loop,nocontrols"]

[NOTE.speaker]
--
In case you just can't contain your curiousity, here's the short version:
--

=== JavaScript becomes more declarative

[.fragment]
--
100 top projects
--

[.fragment]
--

icon:plus[]

Analyzing the Code
--

[.fragment]
--

*=*

JavaScript Becomes [.line-through]#Functional# Declarative
--

[NOTE.speaker]
--
By looking at Github's one hundred most popular javascript projects, analyzing their code and dependencies, we can be
certain that as the years go on, the Javascript community is adopting a more declarative programming style.

How did we manage to get to this conclusion? What it has to do with functional programming, and why even look at
javascript and not, say, C#? All of that and more, next.

But first,
--

== Introduction

video::images/allow-me-to-introduce.mp4[options="loop,nocontrols,autoplay"]

[NOTE.speaker]
--
Before we'll jump into the waters of code analysis, allow me to introduce myself:

--

=== !

[NOTE.speaker]
--
I'm Yoav Luft, born and raised in Israel, currently living with my partner Dafna in Stockholm Sweden. I've have been
programming professionally for the last ten or so years, working mostly with web applications but also with games,
embedded systems and other bits'n'pieces.

Other than programming itself, I'm also involved with the programming community as much as I can. In Israel I've founded
"FLIP", the first functional programming conference in Israel, now preparing for its second round.

I've organized the Elm users group meetups for a while, and I was part of the organizing team of
"HackExtend", a diversity centered hackathon founded by my partner Dafna and friends.

I currently work for the digital agency "Prototyp", a code lab that build code for costumers that want to break new
grounds.
--

[.fragment]
--
Yoav Luft
--

[.fragment]
--
Web Dev - Games - Embedded
--

[.fragment]
--
Founded FLIP - Functional Programming conference in Israel
--

[.fragment]
--
Meetups and Hackathons: Elm TLV, HackExtend
--

[.fragment]
--
Prototyp.se
--


== Why should we care about JavaScript?

image::images/JavaScript-logo.png[50%, 50%]

[NOTE.speaker]
--
Why should we even care about JavaScript? And especially, why should we talk about it in a functional programming
conference?
--

== The Past and Present of Javascript

[NOTE.speaker]
--
Let's start with a brief history of JavaScript: Javascript was created at netscape in 1995 after Brenden Eich (AiK), who
was originally hired to integrate Scheme into the Netscape Navigator, created a prototype in 10 days. It uses a
curly-braces like syntax because management had decided that they want a Java-like programming language. It's goal was
to allow running programs in a web-browser, making web pages interactive, and allowing for a ubiquitous platform.
--

[.step]
- Created at Netscape 1995 by Brenden Eich
- Inspired by Scheme and Self
- Design in just 10 days
- But management wanted C/Java-like syntax

=== !

[NOTE.speaker]
--
Javascript was created with imperative structural syntax similar to C, using control structures such as if-else blocks,
while and for loops. It has functions as first class citizens and supports closures. It is a universally typed language,
aka "dynamically" typed, but also supports some version of object oriented structuring with the use of prototypical
inheritance. 
--

[.step]
- Imperative
- Universally typed
- Functions are 1st class citizens
- Prototypical Inheritance

=== !

[source, javascript]
----
var object = 
  { name: "Object1",
    action: function() { },
    data: [1, 2, 3]
  }

console.log(object["name"] === object.name)
----

[NOTE.speaker]
--
It uses the hashmap as its fundamental data-type, which can also be encoded to a data transfer representation, the JSON
format. It uses late-binding, and allows delegation by the use of the "this" keyword, a feature notoriously confusing
for programs who come from other imperative-object-oriented languages such as Java.

Ölbaum[https://twitter.com/oscherler/status/660049264903643136?lang=en]
--

=== !

.Ölbaum's
image::images/olabums-tweet.png[]

[NOTE.speaker]
--
Being supported on all web browsers, and also being a common backend language through frameworks such as Node.js has
made Javascript extremely popular.
--

=== !

[NOTE.speaker]
--
In StackOverflow's yearly survey of 2018, Javascript was the most popular programming
language with 69% of respondents claiming knowledge of the language
[https://insights.stackoverflow.com/survey/2018/#most-popular-technologies].

It held this position for the last 6 years.
The top 3 most popular frameworks in that same survey are all Javascript frameworks, with Node.js in the lead, which
hints to the language's popularity as a backend language.
--

.Stack Overflow's 2018 Survey
image::images/stack-overflow-2018-popular.png[]

=== !

[NOTE.speaker]
--
According the website SimilarTech, node.js is the fourth most popular server framework, after PHP, ASP.net and Ruby on Rails.
[https://www.similartech.com/categories/framework].
--

.SimilarTech
image::images/similar-tech.png[]

=== !

[NOTE.speaker]
--
On Github, javascript has been the number one programming language
for the last 4 years [https://octoverse.github.com/projects#languages].
Love it or hate it, being the only programming language supported by all web-browsers means that Javascript's popularity
is here to stay. 
--

.Github's Blog Octoverse
image::images/github-survey.png[]

=== !

video::images/why.mp4[options="loop,nocontrols,autoplay"]

[NOTE.speaker]
--
But then again, why should we care, when discussing Javascript in the context of functional programming? 
--

== JavaScript for Functional Programming

[NOTE.speaker]
--
First and foremost, we should note that javascript is a very welcoming language for the flexible functional programmer:
It supports anonymous functions and closures; It uses continuation passing and structured modeling of asynchronous code
quite often;
--

Javascript has:

[%step]
- anonymous functions
- closures
- uses continuation passing
- structured modeling of async (almost monads!)

=== Repeadly Evolving Standard

[NOTE.speaker]
--
And it's repeadly evolving standard includes support for things such as shorthand notation for anonymous
functions (already commonly used), destructuring assignments, constant references, generator functions, and there are
even pending proposals for tail-call optimization, pipe-operator, partial application syntax and pattern matching.
--

- [x] anonymous functions shorthand
- [x] destructuring assignments
- [x] generator functions
- [ ] tail-call optimization (pending)
- [ ] pipe-operator (pending)
- [ ] partial application syntax (pending)
- [ ] pattern matching (pending)

=== !

.ECMA Technical Commitee 39
image::images/TC39.png[50%, 50%]

[NOTE.speaker]
--
It appears that many members of the EMCA Technical Commitee 39, the commitee in charge of the standard used by
javascript implementations, would like to encourage functional programming style in javascript.
As people interested in functional programming, I can only awesome that we would all like to use familiar and beloved
programming style over an imperative, out-styled, and appearently more error prone programming style. This is especially
true if our daily work requires writing code that would run on web browsers.
--

== What does "Adopting functional programming" even means?

=== !

[NOTE.speaker]
--
Just a short google search with the words "Javascript functional programming" will turn out millions of results,
and many of the top results are blog posts about Javascript, or functional programming in javascript.
--

image::images/google-js-fp.png[]

=== !

[NOTE.speaker]
--
But is that a proof that the community as a whole adopts functional programming? Or are these just functional
programming eccentrics howling at the moon?

We can break our question to two parts:

Let's start with "adopting"
--

[.fragment]#Adopting# {nbsp} {nbsp} [.fragment]#functional programming#

== Adopting

[quote, Merriam-Webster Dictionary]
____
*adopt verb*

\ ə-ˈdäpt  \ adopted; adopting; adopts

Definition of adopt [transitive verb]

. to take by choice into a relationship especially: to take voluntarily (a child of other parents) as one's own child
. to take up and practice or use adopted a moderate tone
. to accept formally and put into effect adopt a constitutional amendment
. to choose (a textbook) for required study in a course
. to sponsor the care and maintenance of
    adopt a highway
____

[NOTE.speaker]
--
So in adopting some programming style we imply two things:

Functional programming was not popular, or formally accepted in Javascript

It is now becoming more popular, or being formally accepted

--

=== !

image::images/piece-of-cake.gif[]

== Functional Programming

[NOTE.speaker]
--
Now let us look at the second part of my statement: *Functional programming*.
--

=== How much is javascript functional programming

[NOTE.speaker]
--
What is, exactly, functional programming? How can we define it, and how can we turn such definition to concrete test
cases that we can use to determine "how much" Javascript is functional programming?

When in doubt regarding definitions, I do what every millennial does: I look it up in wikipedia. The wikipedia
definition was a bit mouthful, I will not read it out loud, but just notice the underlined bits:
--

[quote, Wikipedia]
""
[...] functional programming is a programming paradigm—a style of building the structure and elements of
computer programs—that treats [underline]#computation as the evaluation of mathematical functions# and
[underline]#avoids changing-state and mutable data#. It is a [underline]#declarative programming paradigm#, which means
programming is done with expressions or declarations[1] instead of statements. In functional code, the output value of a
function depends only on the arguments that are passed to the function, so calling a function f twice with the same
value for an argument x produces the same result f(x) each time[...]
""

=== !

[%step]
. Computation as the evaluation of mathematical functions
. Avoids changing-state and mutable-data
. Declarative programming paradigm


[NOTE.speaker]
--
Other definitions I found mostly repeated everything stated above, but I would like to note the definition from the
Haskell wiki which states that "[...] the best way to understand functional programming is to learn the basics of one of
the functional programming languages (learn Haskell)."
--

=== Criteria

[NOTE.speaker]
--
Let's see if we can turn them into criteria for estimating how "functional" is a language or a piece of code.

Let's start with "Computation as the evaluation of mathematical functions". What are "mathematical functions" in this
context? Let's try a definition:
--

[quote, Math Insight, https://mathinsight.org/definition/function]
____
A technical definition of a function is: a relation from a set of inputs to a set of possible outputs where each input
is related to exactly one output.
____

=== !

[NOTE.speaker]
--
OK! That's tangible! Let's try and formalize this to a criterion:

While simple, alas, determining such thing for arbitrary Javascript code was a bit out of scope for my research.
--

[quote]
____
A piece of code is more "functional programming" if it uses more mathematical functions.

A mathematical function is such function that its output depends entirely on its arguments.
____

=== Avoid changing state and mutable-data

image:images/smoke.jpg[cover]

[NOTE.speaker]
--
I think this one is both simple and complex at the same time. It is simple because mutability and changing state are
highly related, and very intuitive to grasp. This is complex because [a] all useful programs perform state changes; [b]
it is difficult to differentiate between state transitions or mutability done as part of an algorithm, and those that
are done in order to achieve the required side-effects from the program.

Luckily for us, we've got some help: Many javascript projects use 3rd party packages to provide immutable data structures.
Javascript also added the "const" keyword for immutable reference, and the `Object.freeze()` method for making
objects immutable at runtime. All three can be good and easy to gather indicators for how immutability is common in
javascript.
--

== Declarative Programming Paradigm

[NOTE.speaker]
--
And last but not least, we can look at whether projects adopt a declarative style of programming. Again, a definition is
in order:

While this might sound as vague as the previous definitions, I find that the last bit in there is key:
--

[quote, Wikipedia]
____
a style of building the structure and elements of computer programs—that expresses the logic of a computation without
describing its control flow.
____

=== !

[quote]
____
[...] without describing its control flow.
____

[NOTE.speaker]
--
Javascript, being a language that uses C style imperative structures, comes with a nice set of control flow structures:
--

=== While loops 

.While Loops
[source, javascript]
----
while (condition) {
  doAction()
}

do {
  action()
} while (condition)
----

=== For loops

[NOTE.speaker]
--
Not one, not two, but three different kinds of for loops:

I will not go into the details of what are the differences between the two last for loops. It is not that important.
--

.For Loops
[source, javascript]
----
for (var i = 0; i < size; i++) {
  use(i)
}
for (var property in object) {
  use(property)
}
for (var index of array) {
  use(index)
}
----

=== Branching

[NOTE.speaker]
--
In addition, javascript supports if-else statements, switch statements and labels, which are just a different name to
C's good old GOTO statements.

Now, how would a declarative piece of javascript code would look like? It would avoid control flow structures, but which?
Javascript's alternative to the if statement is rather terse and difficult to read, so it is likely to stay.
Switch statements are still being used as a poor man's pattern matching, and there is
no standardized alternative for them. Labels are rarely seen, so we are left with looping constructs.
--

.If-else
[source, javascript]
----
if (condition) {
  doSomething()
} else {
  doSomethingElse()
}
var a = condition ? val1 : val2
----

.Switch statement
[source, javascript]
----
switch (response) {
  case "yes":
    return true
  case "no":
    return false
  default:
    return undefined
}
----

NOTE: Undefined is javascript's special way to spice up the old billion dollar mistake. Why use just "null" for no-value
      when you can also use "undefined"?

=== Iteration functions

[NOTE.speaker]
--
Luckily for us, looping constructs do have good alternatives: The javascript Array object offers 4 familiar and useful
functions: `map`, `filter`, `forEach` and `reduce`. Here's a small examples of some of them:
--

.Iteration functions
|===================
| Imperative  | Declarative

a|
[source, javascript]
----
var result
for (var i of array) {
  result[i] = f(array[i])
}
----

a|
[source, javascript]
----
var result = array.map(f)
----

a|
[source, javascript]
----
var acc
for (var i of arr) {
  acc = f(acc, arr[i])
}
----

a|
[source, javascript]
----
var accumulated = arr.reduce(f)
----

|===================

=== !

image::images/underscore.png[]

image::images/lodash.png[]

image::images/ramda.png[]

[NOTE.speaker]
--
These functions are built in as part of the Array API, and they have common alternative versions in utility libraries
such as `underscore`, `lodash` and `Ramda`. Combined with some built functions from the `Object` class, such as
`Object.keys` which returns an array of all keys, they are complete enough to represent most, if not all, iteration
constructs required by javascript developers.

Because of these properties I've decided that looping constructs are the best candidates for measuring how much does
Javascript adopts declarative programming.
--

== Where is the Evidence?

video::images/southpark-proof.mp4[options="loop,nocontrols,autoplay"]

[NOTE.speaker]
--
I hope I did not bored you with this prolonged introduction. Armed with the understanding that while the question of
whether Javascript goes functional or not is complicated, the question of whether it becomes more declarative is easier
to answer. Now comes the search for data.
--

== Methods

[NOTE.speaker]
--
After consulting with Prof. Feitelson, I've decided to focus on projects which are:

By looking at how these projects evolve, we can gain insights into general trends in Javascript.
I've decided to use Github's one hundred most popular javascript projects, such as:
--

Projects which are:

. Open source
. Have a lot of contributors
. Have been around for a while


[%notitle]
=== Project examples

// icons
- angular.js image:images/angular.svg[100,100]
- three.js image:images/threejs.png[100, 100]
- Vue.js image:images/vue.png[100, 100]
- D3 image:images/d3.png[100, 100]
- Atom code editor
- etc.

[NOTE.speaker]
--
etc. Next, I've gathered metadata on each project, such as it's number of stargazers and it's number of forks,
dependencies used and so on.
Finally, I've looked at the actual code. By selecting the last commit in each of the years 2009, 2012, 2015, and 2018, I
would see into some of the trends in the overall Javascript programming style.
--

=== !

////
[graphviz]
....
digraph g{
  rankdir=LR; ranksep=0.2; size="8,6";
  repo_list[label="Repository\nList"];
  repo_list -> Metadata [label="fetch"];
  Metadata -> Out [label="save"];
  Metadata -> Commits;
  Commits -> Snapshots;
  Snapshots -> AST;
  AST -> Count;
  Count[label="Count\nPatterns"];
  Count -> Out;
  Out[shape=circle];
}
....
////

image::images/method-graph.svg[]

[NOTE.speaker]
--
Once the commits where selected, I've downloaded a snapshot of each repository at each of the target commits, and sent
the content of the snapshot to a processing pipeline. The processing pipeline uses the Esprima parser to generate an
Abstract Syntax Tree for each file, which was then searched for specific patterns.
--

=== Patterns

[NOTE.speaker]
--
For each files of valid Javascript, I've looked for the following patterns:
--

- for loop

- for..in loops

- for..of loops

[source, javascript]
----
for (var i = 0; i < size; i++) {...}
for (var i in object) {...}
for (var i of array) {...}
----

- while and do-while loops

[source, javascript]
----
while (cond) {...}
----

=== !

- forEach calls:

[source, javascript]
----
arr.forEach(f); _.forEach(arr, f); _.each(arr, f)
----

- map calls and aliases such as

  `map`, `pluck`, `flatMap`, `collect`

- filter calls and aliases:

  `filter`, `select`, `reject`, `where`

- reduce calls and aliases:

  `reduce`, `reduceRight`, `foldl`, `foldr`


[NOTE.speaker]
--
After filtering some problematic repositories, I moved into analyzing the results.
--

== Results

[NOTE.speaker]
--
Let's start with a short survey of the repositories:
--

=== Repositories

.Repositories in Each Sampled year
image::images/num_projects_sample_year.png[]

[NOTE.speaker]
--
We can see in this graph that out of the hundred top rated repositories only 79 had meaningful data in at the end of
2018, and as for 2009, only 3 had any data at all.
--

NOTE: Sample - a snapshot of a projects code at a specific time. Not all projects had samples at all times.

=== Repositories by Age

.Repositories by Age
image::images/created_year_cdf.png[]

[NOTE.speaker]
--
// Double check that
This brings the question of the age of the repositories. We can see that over half of them were created on Github at
before 2014. This means they have at least 5 years of development in the public domain, which I find to be very important.
This graph uses only the metadata of the repositories, so it has some repositories that turned out to have no data at
all.
--

=== Size of Repos

.Lines of code Per Sample
image::images/loc_files_per_sample_year.png[]

[NOTE.speaker]
--
How large were the projects?

These two graphs show the total number of parsed Javascript files in each sampled year, and the sum of lines of code for
each sample. We can see that we're dealing with magnitude of 3 million lines of code. We can also witness the rapid
growth of Javascript from 2012 to 2015, almost tripling the number of lines of code, while only doubling the number of
files. We can see that from 2015 to 2018 the number of lines of code grows more slowly, but the number of files keeps on
growing steadily. This is an indication that code is broken into smaller files, maybe due to refactoring of the
projects? It is difficult to say conclusively.
--

=== Iteration Constructs in Samples

.Number of Iteration Constructs in Each Year Sample
image::images/num_constructs_year.png[]

[NOTE.speaker]
--
Next, we'll look at the how common are different code constructs in different samples:

Some orientation for this graph: This is the stacked count of iteration constructs extracted from all projects, plotted
by year of the project snapshot used. Below the green line are the declarative constructs, from top: forEach, reduce,
map and filter. Above the green line are the imperative constructs, from top: while, for..of, for..in and C-style for.

We can notice that from 2015 to 2018 the total number of iteration constructs had stayed roughly the same, but we
already know that the amount of code had increased. We can also see that the declarative part is slightly raising, and
also that C-style for loops are the most popular interation construct.
--

=== Iteration Constructs per Line of Code

.Number of Iteration Construct per Lines of Code
image::images/percent_constructs_year.png[]

[NOTE.speaker]
--
Let's look at the same data normalized by the number of lines of code in each sample:

In this graph it becomes obvious that as time advances, there are less iteration constructs in general. Is that
because projects use APIs which are even more high-level than the ones I'm sampling, or is because more code is dedicated
to configurations and simpler business logic?

Finally, we can see that while the total number of iteration constructs shrink, the part of the declarative constructs
shrinks more slowly. Let's have a look at the relative amount of each construct compared to the others:
--

=== Iteration Constructs in Percentage

.Percentage of Iteration Constructs over Years
image::images/dist_constructs_year.png[]

[NOTE.speaker]
--
Now, here we can see an obvious trend: declarative iteration constructs are on the rise compared to their imperative
counterparts. Still, they are only slightly more that 40% of total constructs use, with C-style for loops still in the
lead with 34% of all constructs found. While loops are slowly disappearing, dropping from 13% to just 9.6% over the last
6 years, while the use of `map` is slowly on the rise. Surprisngly enough, the use of reduce, while rare, is quite
constants, being around 1% of all constructs over all samples.

It seems like this supports the idea that javascript is moving to more declarative iteration constructs, but it seems
like this process is not as fast as I originally had guessed. Let's try and look what kind of projects change the
most.
--

== Change in individual projects

.Ratio of Declarative Iterations per Project over Samples
image::images/decl_ratio_per_project_over_time.png[]

Declarative Index: latexmath:[$\frac{Declarative}{Declarative + Imperative}$]

[NOTE.speaker]
--
For 66 of the projects, I had more than one sample, meaning that we can look on the change of these projects both
individually and as a group.

This graph is a bit difficult to follow, considering the amount of data in it. For each project in each sample I took
the number of declarative iteration constructs and divided it by the number of total iteration constructs. The result is
the ratio of declarative iterations for each project, over time. "One" means that only declarative iterations where used,
and "zero" means that only imperative iterations where used.

We can see that projects go in both ways: Some of them started mostly declarative and retained their ratio, while others
started imperative and became declarative, or even started declarative and slowly became more imperative. I've plotted the
mean ratio as the thick magenta coloured line. We can see that while projects took different paths, the overall trend is
quite obvious, moving from a 0.4 ratio to 0.6 ratio over the last 6 years.

Is there anything that can predict whether a project will choose or turn to a more declarative style?
--

=== Project Properties

.Declarative Ratio by Number of Project Forks
image::images/declarative_by_forks.png[]

[NOTE.speaker]
--
Let's look at the number of forks a project has and it's "declarative ratio" index:

We can see that more forks are anti-correlated with the project's "Declarative Index" that we defined before. Not the
most promising data for us.
--


=== Project Age as Estimator

.Declarative Ratio by Project Age in Years
image::images/declarative_by_age.png[]

[NOTE.speaker]
--
Let's look at the age of the project:

That's interesting! We can see that there's a slight negative correlation between project age and it's "declarative
index". That means that the newer the project, the more likely it is to prefer a declarative style. In fact, we can see
that projects created at the last 5 years use declarative iterations 63% of the time, in average, compared to 51% for
older projects.
--

=== Project Stargazers

.Forks vs Stargazers
image::images/forks_vs_stars.png[]

[NOTE.speaker]
--
What about the popularity of the project, represented by the number of "stargazers"? First, it is strongly correlated
with number of forks

So intuitively, I would expect it to be similar to the relation between the declarative index and the number of forks.
Let's see:
--

=== !

.Declarative Ratio by Stars
image::images/declarative_by_stars.png[]

[NOTE.speaker]
--
Interestingly enough, there is no correlation! But I wouldn't put to much meaning into this graph, because being a
stargazer of a project doesn't have some inherent well understood meaning, similar to a "like" on twitter or facebook.

Finally, let's see how the number of contributors correlates with the projects "declarative index":
--

=== Project Contributors

.Declarative Ratio by Number of Contributors
image::images/declarative_by_contributors.png[]

[NOTE.speaker]
--
Word of caution: I scraped this data directly from each projects Github page, and I'm not sure exactly what is the
metric that they use. It might be the number of contributors in the last year, month, or the entire history of the
project. We can only hope and assume that this metric is consistent.

From the number of contributors we can see that there is some correlation between more contributors and more declarative
style of code. This might imply that the majority of javascript programmers prefer a declarative style of coding.
--

== What About Functional Programming

[NOTE.speaker]
--
As for the question of functional programming as a whole, while it is more complicated, I managed to find some data that
can improve our understanding.

For example, from analyzing the dependencies of our sample projects, we can try and learn how many use helper libraries
that make functional programming in javascript easier, such as "underscore", "lodash" and "Ramda"

Well, we can see that helper libraries have definetely became more popular over the years, but they are still being used
by less than a quarter of our sample.
--

.Helper Libraries Use
image::images/helpers_libs.png[]

////
NOTE: Helper libraries provide high level API over data structures, for example a "groupby" function over fields, or
"mapValues" that can be used to map object values. Some of them, like Ramda, use conventions popular in languages such
Haskell and Elm
////

=== Immutable Data and Data Structures

image::images/fantasy-land.png[]
image::images/static-land.png[]
image::images/immutablejs.png[]

[NOTE.speaker]
--
There are some libraries which provide facilities for immutable data structures in JavaScript, and some libraries for
advance data structures, such as Algebraic Data Types. Unfortunetaly, I couldn't find any project in my sample who used
either of them. 
--

== What's Next

[NOTE.speaker]
--
As for my research, there are some obvious steps forward:

And of course, there are so many small improvements to make, such as supporting more flavors of Javascript, and even
looking at Javascript's typed superset, TypeScript.
--

[.step]
- Look at a larger sample
- Examine more structures, e.g. assignments
- Look at the use of higher-order functions
- Examine results into more detail.
  - How easy it is to convert imperative iterations to declarative ones?
- Examine changes of code over time
- Look for projects migrating from Javascript to functional languages

== No, no, no, I meant what's next for me...

[NOTE.speaker]
--
Oh! Well, if you don't like Javascript but need to write code that runs in a web browser there are several nice
alterantives:

Elm - a small delightful language that IMHO solves many of the problems in web programming

ClojureScript -  if you just can live another project without LISP

PureScript - a Haskell-like language that compiles to Javascript and has some tweeks for nicer interpolation with
Javascript.

Reason - an OCaml inspired language that started trending lately, mostly due to it's easy interop with Javascript.

100s of Language X to Javascripts - Hundreds of other programming languages that can compile themselves to Javascript,
such as Haskell, Kotlin, Scala, Ruby, Python. 

Google any word with "Script" as suffix or that is a pun on coffee and there's probably a Javascript dialect or a
language that transpiles to Javascript by that name.

Wait for the Web assembly standard to mature and then just write code in whatever languae you want.
--

// Icons

[.step]
- Elm
- ClojureScript
- PureScript
- ReasonML
- 100s of Language X to Javascripts
- WebAssembly

[.fragment]
Here's a list: https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js

== Shameless Plug

[NOTE.speaker]
--
If you find this project interesting, you can contribute to the code through it's repo on github, or by encouraging me
to keep researching programming languages.

I work for Prototyp, where we <put slogan here>. We're located in Stockholm and Barcelona and would be happy to help you
with your projects.
--

== Thank you!

== Questions?

